{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"14866515028293298530","abi":{"parameters":[{"name":"plaintext_bytes","type":{"kind":"array","length":224,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"eph_pk_x","type":{"kind":"field"},"visibility":"private"},{"name":"ciphertext_bytes","type":{"kind":"array","length":496,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"ivsk_app","type":{"kind":"field"},"visibility":"private"},{"name":"block_number","type":{"kind":"field"},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"private"},{"name":"price_feed_address","type":{"kind":"field"},"visibility":"private"},{"name":"price_feed_assets_slot","type":{"kind":"field"},"visibility":"private"},{"name":"public_data_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"price_witness","type":{"kind":"struct","path":"utils::PriceWitness","fields":[{"name":"leaf_preimage","type":{"kind":"struct","path":"utils::PublicDataLeafPreimage","fields":[{"name":"slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"next_slot","type":{"kind":"field"}},{"name":"next_index","type":{"kind":"field"}}]}},{"name":"witness_index","type":{"kind":"field"}},{"name":"witness_path","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"initial_lots","type":{"kind":"array","length":8,"type":{"kind":"struct","path":"utils::Lot","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"cost_per_unit","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"initial_num_lots","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2014890719615096298":{"error_kind":"string","string":"Field failed to decompose into specified 40 limbs"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3997414936228002054":{"error_kind":"string","string":"Ephemeral PK sign mismatch"},"4648451262681811962":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"9599997976408299955":{"error_kind":"string","string":"Not enough lots to cover sell amount"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12614869966491922937":{"error_kind":"string","string":"Lot array full"},"14792281122409280459":{"error_kind":"string","string":"Token price must not be zero"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15547888361292242929":{"error_kind":"string","string":"Swap does not involve tracked token"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"16243108538394308354":{"error_kind":"fmtstring","length":41,"item_types":[]},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17949044289887411793":{"error_kind":"string","string":"Body ciphertext mismatch"},"18055728914098955818":{"error_kind":"string","string":"Merkle membership proof failed"}}},"bytecode":"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","debug_symbols":"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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function assumes that the points are on the curve\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // avoid calling the black box function for trivial cases\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_inner(point1, point2)\n        }\n    } else {\n        embedded_curve_add_inner(point1, point2)\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// EC addition wrapper for the foreign function\nfn embedded_curve_add_inner(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"51":{"source":"mod utils;\n\nuse dep::protocol_types::hash::poseidon2_hash;\nuse utils::{\n    PLAINTEXT_BYTES_LEN, CIPHERTEXT_BYTES_LEN, MAX_LOTS,\n    Lot, PriceWitness,\n    compute_public_data_tree_index,\n    derive_storage_slot_in_map,\n    extract_plaintext_field,\n    hash_lots,\n    verify_and_read_public_data,\n    verify_encryption,\n};\n\n/// Proves a single swap event and computes FIFO capital gains for a tracked token.\n/// Uses i64 arithmetic for PnL to safely handle negative gains (losses).\n///\n/// Oracle prices must have at most 4 decimal precision (scaled by 10^4).\n/// Token amounts must fit in i64 (< 9.2 * 10^18). With 4-decimal prices,\n/// amount * price products fit safely in i64 for any realistic values.\n///\n/// Returns: (leaf_hash, pnl, pnl_is_negative, remaining_lots_hash, initial_lots_hash, price_feed_address)\nfn main(\n    // Swap event\n    plaintext_bytes: [u8; PLAINTEXT_BYTES_LEN],\n    eph_pk_x: Field,\n    ciphertext_bytes: [u8; CIPHERTEXT_BYTES_LEN],\n    ivsk_app: Field,\n    block_number: Field,\n\n    // Token identification (the token whose lots we track)\n    token_address: Field,\n\n    // Oracle price data (only the tracked token's price)\n    price_feed_address: Field,\n    price_feed_assets_slot: Field,\n    public_data_tree_root: Field,\n    price_witness: PriceWitness,\n\n    // FIFO lot state from previous proof\n    initial_lots: [Lot; MAX_LOTS],\n    initial_num_lots: u32,\n) -> pub (Field, Field, Field, Field, Field, Field) {\n    // 1. Verify encryption (proves swap event is authentic)\n    verify_encryption(plaintext_bytes, eph_pk_x, ciphertext_bytes, ivsk_app);\n\n    // 2. Extract swap values from plaintext\n    // Layout: [metadata, randomness, token_in, token_out, amount_in, amount_out, is_exact_input]\n    let token_in = extract_plaintext_field(plaintext_bytes, 2);\n    let token_out = extract_plaintext_field(plaintext_bytes, 3);\n    let amount_in = extract_plaintext_field(plaintext_bytes, 4);\n    let amount_out = extract_plaintext_field(plaintext_bytes, 5);\n    let is_exact_input = extract_plaintext_field(plaintext_bytes, 6);\n\n    // 3. Compute leaf hash (commits to the raw swap data)\n    let leaf = poseidon2_hash(\n        [block_number, token_in, token_out, amount_in, amount_out, is_exact_input],\n    );\n\n    // 4. Determine direction (does the tracked token appear as in or out?)\n    let is_buy = (token_out == token_address);\n    let is_sell = (token_in == token_address);\n    assert(is_buy | is_sell, \"Swap does not involve tracked token\");\n\n    // 5. Read oracle price for TOKEN at this block\n    let token_slot = derive_storage_slot_in_map(price_feed_assets_slot, token_address);\n    let tree_index = compute_public_data_tree_index(price_feed_address, token_slot);\n    let token_price = verify_and_read_public_data(\n        public_data_tree_root, tree_index, price_witness,\n    );\n    assert(token_price != 0, \"Token price must not be zero\");\n\n    // 6. Hash initial lot state (for chaining verification)\n    let initial_lots_hash = hash_lots(initial_lots, initial_num_lots);\n\n    // 7. Process swap: update FIFO lots and compute gains using i64 arithmetic\n    let mut lots = initial_lots;\n    let mut num_lots = initial_num_lots;\n    let mut pnl: i64 = 0;\n\n    if is_buy {\n        // BUY: acquired the tracked token\n        // Create a new lot at current oracle price\n        assert((num_lots as u64) < (MAX_LOTS as u64), \"Lot array full\");\n        lots[num_lots] = Lot { amount: amount_out, cost_per_unit: token_price };\n        num_lots += 1;\n    } else {\n        // SELL: disposed of the tracked token\n        // Consume lots FIFO, accumulate signed PnL\n        let sell_price: i64 = token_price as i64;\n        let mut remaining: i64 = amount_in as i64;\n\n        for j in 0..MAX_LOTS {\n            let lot_amount: i64 = lots[j].amount as i64;\n            let lot_cost: i64 = lots[j].cost_per_unit as i64;\n\n            if (remaining != 0) & (lot_amount != 0) {\n                let consumed: i64 = if remaining < lot_amount { remaining } else { lot_amount };\n\n                let proceeds = consumed * sell_price;\n                let cost = consumed * lot_cost;\n                pnl += proceeds - cost;\n\n                lots[j].amount = (lot_amount - consumed) as u64 as Field;\n                remaining -= consumed;\n            }\n        }\n        assert(remaining == 0, \"Not enough lots to cover sell amount\");\n\n        // Compact: shift non-empty lots to the front so empty slots can be reused\n        let mut compacted: [Lot; MAX_LOTS] = [Lot { amount: 0, cost_per_unit: 0 }; MAX_LOTS];\n        let mut write_idx: u32 = 0;\n        for j in 0..MAX_LOTS {\n            if lots[j].amount != 0 {\n                compacted[write_idx] = lots[j];\n                write_idx += 1;\n            }\n        }\n        lots = compacted;\n        num_lots = write_idx;\n    }\n\n    // 8. Hash remaining lot state (for chaining to next proof)\n    let remaining_lots_hash = hash_lots(lots, num_lots);\n\n    // 9. Encode signed PnL as (magnitude, is_negative) for Field output\n    let pnl_is_negative: Field = if pnl < 0 { 1 } else { 0 };\n    let pnl_abs: Field = if pnl < 0 { (-pnl) as u64 as Field } else { pnl as u64 as Field };\n\n    (leaf, pnl_abs, pnl_is_negative, remaining_lots_hash, initial_lots_hash, price_feed_address)\n}\n","path":"/Users/jp4g/Workground/aztec/fde/pnl-proof/circuits/individual_swap/src/main.nr"},"52":{"source":"use dep::aztec::{\n    messages::encryption::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe,\n    keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n    utils::point::{point_from_x_coord_and_sign, get_sign_of_point},\n};\nuse dep::std::{aes128::aes128_encrypt, embedded_curve_ops::EmbeddedCurveScalar};\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::{poseidon2_hash, poseidon2_hash_with_separator},\n    merkle_tree::root::root_from_sibling_path,\n    utils::field::full_field_less_than,\n};\n\n// ============================================================\n// Public Data Tree\n// ============================================================\n\npub global PUBLIC_DATA_TREE_HEIGHT: u32 = 40;\n\npub struct PublicDataLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl PublicDataLeafPreimage {\n    pub fn hash(self) -> Field {\n        let is_empty = (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0);\n        if is_empty {\n            0\n        } else {\n            poseidon2_hash([self.slot, self.value, self.next_index, self.next_slot])\n        }\n    }\n}\n\npub struct PriceWitness {\n    pub leaf_preimage: PublicDataLeafPreimage,\n    pub witness_index: Field,\n    pub witness_path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\npub fn compute_public_data_tree_index(contract_address: Field, storage_slot: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address, storage_slot],\n        GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    )\n}\n\npub fn derive_storage_slot_in_map(storage_slot: Field, key: Field) -> Field {\n    poseidon2_hash([storage_slot, key])\n}\n\npub fn verify_and_read_public_data(\n    public_data_tree_root: Field,\n    tree_index: Field,\n    witness: PriceWitness,\n) -> Field {\n    let leaf_hash = witness.leaf_preimage.hash();\n    let computed_root = root_from_sibling_path(leaf_hash, witness.witness_index, witness.witness_path);\n    assert_eq(computed_root, public_data_tree_root, \"Merkle membership proof failed\");\n\n    let is_less_than_slot = full_field_less_than(witness.leaf_preimage.slot, tree_index);\n    let is_next_greater_than = full_field_less_than(tree_index, witness.leaf_preimage.next_slot);\n    let is_max = (witness.leaf_preimage.next_index == 0) & (witness.leaf_preimage.next_slot == 0);\n    let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n    if is_in_range {\n        0\n    } else {\n        assert_eq(witness.leaf_preimage.slot, tree_index, \"Public data tree index doesn't match witness\");\n        witness.leaf_preimage.value\n    }\n}\n\n// ============================================================\n// Byte Helpers\n// ============================================================\n\npub global SWAP_PLAINTEXT_FIELDS: u32 = 7;\npub global PLAINTEXT_BYTES_LEN: u32 = 224; // 7 fields * 32 bytes\npub global CIPHERTEXT_BYTES_LEN: u32 = 496; // 16 ciphertext fields * 31 bytes each\nglobal HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    for i in 0..32 {\n        result = result * 256 + bytes[i] as Field;\n    }\n    result\n}\n\npub fn extract_plaintext_field(plaintext_bytes: [u8; PLAINTEXT_BYTES_LEN], index: u32) -> Field {\n    let mut field_bytes = [0 as u8; 32];\n    let offset = index * 32;\n    for j in 0..32 {\n        field_bytes[j] = plaintext_bytes[offset + j];\n    }\n    bytes_to_field(field_bytes)\n}\n\n// ============================================================\n// Encryption Verification\n// ============================================================\n\npub fn verify_encryption(\n    plaintext_bytes: [u8; PLAINTEXT_BYTES_LEN],\n    eph_pk_x: Field,\n    ciphertext_bytes: [u8; CIPHERTEXT_BYTES_LEN],\n    ivsk_app: Field,\n) {\n    let eph_pk_sign_byte = ciphertext_bytes[0];\n    let eph_pk_sign = eph_pk_sign_byte != 0;\n\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign)\n        .expect(f\"Invalid ephemeral public key x-coordinate\");\n    let recipient_sk_scalar = EmbeddedCurveScalar::from_field(ivsk_app);\n    let shared_secret = derive_ecdh_shared_secret(recipient_sk_scalar, eph_pk);\n\n    let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(shared_secret);\n    let (body_sym_key, body_iv) = pairs[0];\n\n    let computed_body = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n    let body_start = 1 + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    for i in 0..computed_body.len() {\n        if body_start + i < ciphertext_bytes.len() {\n            assert(\n                computed_body[i] == ciphertext_bytes[body_start + i],\n                \"Body ciphertext mismatch\",\n            );\n        }\n    }\n\n    assert(eph_pk_sign_byte == get_sign_of_point(eph_pk) as u8, \"Ephemeral PK sign mismatch\");\n}\n\n// ============================================================\n// FIFO Lot Tracking\n// ============================================================\n\npub global MAX_LOTS: u32 = 8;\npub global LOTS_HASH_PREIMAGE_LEN: u32 = 17; // MAX_LOTS * 2 + 1\n\npub struct Lot {\n    pub amount: Field,\n    pub cost_per_unit: Field,\n}\n\npub fn hash_lots(lots: [Lot; MAX_LOTS], num_lots: u32) -> Field {\n    let mut preimage: [Field; LOTS_HASH_PREIMAGE_LEN] = [0; LOTS_HASH_PREIMAGE_LEN];\n    preimage[0] = num_lots as Field;\n    for i in 0..MAX_LOTS {\n        preimage[1 + i * 2] = lots[i].amount;\n        preimage[1 + i * 2 + 1] = lots[i].cost_per_unit;\n    }\n    poseidon2_hash(preimage)\n}\n","path":"/Users/jp4g/Workground/aztec/fde/pnl-proof/circuits/individual_swap/src/utils.nr"},"95":{"source":"use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ECDH shared secret: secret * public_key = shared_secret.\n///\n/// The input secret is known only to one party. The output shared secret can be derived given knowledge of\n/// `public_key`'s key-pair and the public ephemeral secret, using this same function (with reversed inputs).\n///\n/// E.g.:\n/// Epk = esk * G // ephemeral key-pair\n/// Pk = sk * G // recipient key-pair\n/// Shared secret S = esk * Pk = sk * Epk\n///\n/// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    multi_scalar_mul([public_key], [secret])\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().unwrap().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().unwrap().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret =\n        derive_ecdh_shared_secret(secret_a, address_b.to_address_point().unwrap().inner);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr"},"133":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"238":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"249":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/jp4g/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"338":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"347":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"390":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"}},"expression_width":{"Bounded":{"width":4}}}