{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"15545654536214982923","abi":{"parameters":[{"name":"plaintext_bytes","type":{"kind":"array","length":224,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"eph_pk_x","type":{"kind":"field"},"visibility":"private"},{"name":"ciphertext_bytes","type":{"kind":"array","length":496,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"ivsk_app","type":{"kind":"field"},"visibility":"private"},{"name":"block_number","type":{"kind":"field"},"visibility":"private"},{"name":"initial_lot_state_root","type":{"kind":"field"},"visibility":"private"},{"name":"sell_lots","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"utils::Lot","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"cost_per_unit","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"sell_num_lots","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"sell_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"sell_sibling_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"buy_lots","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"utils::Lot","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"cost_per_unit","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"buy_num_lots","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"buy_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"buy_sibling_path","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"},{"name":"price_feed_address","type":{"kind":"field"},"visibility":"private"},{"name":"price_feed_assets_slot","type":{"kind":"field"},"visibility":"private"},{"name":"public_data_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"sell_price_witness","type":{"kind":"struct","path":"utils::PriceWitness","fields":[{"name":"leaf_preimage","type":{"kind":"struct","path":"utils::PublicDataLeafPreimage","fields":[{"name":"slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"next_slot","type":{"kind":"field"}},{"name":"next_index","type":{"kind":"field"}}]}},{"name":"witness_index","type":{"kind":"field"}},{"name":"witness_path","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"buy_price_witness","type":{"kind":"struct","path":"utils::PriceWitness","fields":[{"name":"leaf_preimage","type":{"kind":"struct","path":"utils::PublicDataLeafPreimage","fields":[{"name":"slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"next_slot","type":{"kind":"field"}},{"name":"next_index","type":{"kind":"field"}}]}},{"name":"witness_index","type":{"kind":"field"}},{"name":"witness_path","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"previous_block_number","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"2014890719615096298":{"error_kind":"string","string":"Field failed to decompose into specified 40 limbs"},"2665467139550344392":{"error_kind":"string","string":"Sell-side merkle proof failed against initial root"},"2967937905572420042":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"3330370348214585450":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"3997414936228002054":{"error_kind":"string","string":"Ephemeral PK sign mismatch"},"4579868045596057809":{"error_kind":"string","string":"Sell token price must not be zero"},"4648451262681811962":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"7986223047253709792":{"error_kind":"string","string":"Buy lot array full"},"9599997976408299955":{"error_kind":"string","string":"Not enough lots to cover sell amount"},"9624308173915377683":{"error_kind":"string","string":"Buy token price must not be zero"},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"12307621902480398216":{"error_kind":"string","string":"Buy-side merkle proof failed against intermediate root"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"14055999996366974295":{"error_kind":"string","string":"Block number must be >= previous block number"},"14486391642420115797":{"error_kind":"string","string":"Field failed to decompose into specified 3 limbs"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"16243108538394308354":{"error_kind":"fmtstring","length":41,"item_types":[]},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17949044289887411793":{"error_kind":"string","string":"Body ciphertext mismatch"},"18055728914098955818":{"error_kind":"string","string":"Merkle membership proof failed"}}},"bytecode":"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","debug_symbols":"tP3RsvPKkp2Hvktf6wKZlVWZ6VdxnFC0bdnRER0thyyfG4Xe/UyAqPqye58fsxbJdaN/9NaaNQiQOTBIfAD+xz/9H//lf/t//6///C//9n/+1//nn/6X//V//NP/9t/+5V//9V/+r//8r//1f//n//4v//Xffv7X//FPx/n/SP7T/yLHf/onPe5/5f5X73/bz7/686/d//b733H/6/e/cf+br3/bcf8r9796/3uv1+712r1eu9dr93rtXq/d69m9nt3r2b2e3evZvZ7d69m9nt3r2b2e3ev1e71+r9fv9fq9Xr/X6/d6/V6v3+v1e71+rzfu9ca93rjXG/d6415v3OuNe71xrzfu9ca9nt/r+b2e3+v5vZ7f6/m9nt/r+b2e3+v5vV7c68W9Xtzrxb1e3OvFvV7c68W9Xtzrxb1e3uvlvV7e6+W9Xt7r5b1e3uvlvV7e6+W9nhzHFDKFTtGmsCn6FGMKnyKmmCvLXFnmyjJXlrmyzJVlrixzZZkry1xZ5so6V9a5ss6V59zIHByZkyNzdGTOjszhkTk9MsdH5vzIHCCZEyRzhGTOkMwhkjlFMsdI5hzJHCSZkyRzlGTOksxhkjlNMsdJ5jzJHCiZEyVzpGTOlMyhkjlVMsdK5lzJHCyZkyVztGTOlszhkjldMsdL5nzJHDCZEyZzxGTOmMwhkzllMsdM5pzJHDSZkyZz1GTOmsxhkzltMsdN5rzJHDiZEydz5GTOnMyhkzl1MsdO5tzJHDyZkydz9GTOnszhkzl9MsdP5vzJHECZEyhzBGXOoM4Z1DmDOmdQ5wzqnEGdM6hzBnXOoM4Z1DmDOmdQ5wzqnEGdM6hzBnXOoM4Z1DmDOmdQ5wzqnEGdM6hzBnUdu9bBax291uFrHb/WAWzOoM4Z1DmDOmdQ5wzqnEGdM6hzBnXOoM4Z1DmDOmdQ5wzqnEG1dbydK88Z1DmDOmdQ5wzqnEGdM6hzBnXOoM4Z1L4O5XPlOYM6Z1DnDOqcQZ0zqHMGdc6gzhnUOYM6VkuYK88Z1DmDOmdQ5wzqnEGdM6hzBnXOoM4ZVF8FZK48Z1DnDOqcQZ0zqHMGdc6gzhnUOYM6Z1BjdZu58pxBnTOocwZ1zqDOGdQ5gzpnUOcM6pxBzVWbVm+axWnOYJsz2OYMtjmDbc5gmzPY5gy2OYNtzmCTVcnmynMG25zBNmewzRlscwbbnME2Z7DNGWxzBpuutjdXnjPY5gy2OYNtzmCbM9jmDLbVIleNXD2SIjlXXlVydclVJlebXHVyzmCbM9jmDLY5g81WR50rzxlscwbbnME2Z7DNGWxzBtucwTZnsM0ZbH3V37nynME2Z7DNGWxzBtucwTZnsM0ZbHMG25zBNlaznivPGWxzBtucwTZnsM0ZbHMG25zBNmewzRlsvkr7XHnOYJsz2OYMtjmDbc5gmzPY5gy2OYNtzmCL9X1grjxnsM0ZbHMG25zBNmewzRlscwbbnME2Z7Dl+qqxvmvMLxtzBm3OoM0ZtDmDNmfQ5gzanEGbM2hzBk3W15i58pxBmzNocwZtzqDNGbQ5gzZn0OYM2pxB0/UNaa48Z9DmDNqcQZszaHMGbc6gzRm0OYM2Z9Da+vI1V54zaHMGbc6gzRm0OYO2vtOtL3XrW936Wsf3urny+ma3vtqt73bry92cQZszaHMGbc6gzRm0vr4yzpXnDNqcQZszaHMGbc6gzRm0OYM2Z9DmDNpY30bnynMGbc6gzRm0OYM2Z9DmDNqcQZszaHMGzdcX3bnynEGbM2hzBm3OoM0ZtDmDNmfQ5gzanEGL9R16rjxn0OYM2pxBmzNocwZtzqDNGbQ5gzZn0HJ9PV/fz+cX9DmDfc5gnzPY5wz2OYN9zmCfM9jnDPY5g13WV/+58pzBPmewzxnscwb7nME+Z7DPGexzBvucwa7rV4W58pzBPmewzxnscwb7nME+Z7DPGexzBvucwd7WDxZz5TmDfc5gnzPY5wz2a5raKc7/xU5xevVTnF7j/MXj9PJTyBQ/XiqnaFPYFH2KMYVPEVPkLc7ZeQmZYq485spjrjzmymOuPObKY6485so+V/a5ss+Vfa7sc2WfK/tc2efKPlf2uXLMlWOuHHPlmCvHXDnmyjFXjrlyzJVjrpxz5Zwr51w558o5V865cs6Vc66cc+W8Vx7HMYVMoVO0KWyKPsWYwqeIKebKMleWubLMlWWuLHNlmSvLXFnmyjJXlrmyzpV1rqxzZZ0r61xZ58o6V9a5ss6Vda7c5sptrtzmym2u3ObKba7c5sptrtzmym2ubHNlmyvbXNnmyjZXtrmyzZVtrmxzZZsr97lynyvPGRxzBsecwTFncMwZHHMGx5zBMWdwzBkccwbHnMExZ3DMGRxzBsecwTFncMwZHHMGx5zBMWdwzBkccwbHnMExZ3DMGRxzBsecwTFncMwZHHMGx5zBMWdwzBkccwbHnMExZ3DMGRxzBsecwTFncMwZHHMGx5zBMWdwzBkccwbHnMExZ9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGfc6gzxn0OYM+Z9DnDPqcQZ8z6HMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDmDMacwZgzGHMGY85gzBmMOYMxZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGc85gzhnMOYM5ZzDnDOacwZwzmHMGf86tH0vJUrpUW8qW6kuNpXypWGp5yPKQ5SHLQ5aHLA9ZHrI8ZHnI8pDloctDl4cuD10eujx0eejy0OWhy0OXR1sebXm05dGWR1sebXm05dGWR1sebXnY8rDlYcvDloctD1setjxsedjysOXRl0dfHn159OXRl0dfHn159OXRl0dfHmN5jOUxlsdYHmN5XKOqlzpX6ae6hvWlZKlzFb9UW8qWOl9VnOoax7zU+bd2KV3q52/bcamfv23XKzhn8lZjKV/q5/W16/Wdc/lS52DeSpbSpdpStlRf6lzv5wc3ubiWZpc6/3/7pc5XMC7lS8VSOdU5R7c6/9YvNZY6//bcGxeQ0vJSP/+dHZcaS/lSPx4ml8qpzs/9rWSud37u7/+tLWVL9aXG3Lbzc3+rWCqnsrUd52f89erPz/it1rZdn+frFZyfZzv35IWX2LUnz8/zrXSptpQt1ZcaS5374Hot5+f5VjnV+Xm26505P892vdLz82zXqzo/z3a9quvzfO3n66j0UmOpc71LnZ/sW8lScz5kHolE5qFILqKkX+/R+cnu1/92/Wp//e31s/1L/fxtv/bL+cnu17adn+xbjaV8qZ/t7ddWnp/slzo/2beSpXSptpQt1Zc61zv31UWL9HGp83/zS50e57660I9byVK6VF/q/Nu8VE51fp7Hcamf1zLkUj//3dBL5VTnZ/dWPx6jXUqXakvZXO/87N7/21jKl4qlcm7bmdm3Wtt7fp5vtbbjzOfXqz/z+VZr287P7vX+XmDGsEudr+/ak+dn91Z9qbGULxVL5VTnZ3dcr+X87N5Klzo9rnfm/OyO65Wen91xvarzs+vXqzo71fWpu0CNW+VU1wmpa7+cn11//W8/6/m1788edauxlC8VS+VU52f8Vj+v2a+Vz8/4rdpSp8e1r87PuF/be37G/dq28zPu17ZdJ6he/11OdZ2isv/5Iy/e9Twl8vN/6Pw/Tvczn14IbHsRsO0FwLYX/9pe+Gt70a/tBb+2m0X9WavNtc7X5a9/zjfotbK/Vvb/+fNfTv72P//3//Zf/sv5VwXI/V//xz/93//83/7Lv/33f/pf/u3//dd//U//9P/953/9f6//6P/5v//5365///s//7ef/9+f9+m//Nv/8fPvz4L/57/863851f/8T/z18ec/lbNm3H9+Hn36WkJid408zxZdK/x8PeLvffvvzzF5/b3nG38f56H9+vuf3wv+9Pf2578f50Bcf//zI/Qbf//z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ZvHN4pvFt+SVlLySkldS8kpKXknJKyl5JSWvpOSVlLySkldS8kpKXknJKyl5JSWvpOSVlLySkldS8kpKXknJKyl5JSWvpOSVlLySkldS8kpKXknJKyl5JSWvpOSVlLySkldS8kpKXknJKyl5JSWvpBVfK75WfK34WvG14lvySkpeSckrKXklJa+k5JWUvJKSV1LySkpeSckrKXklJa+k5JWUvJKSV1LySkpeSckrKXklJa+k5JWUvJKSV1LySkpeSckrKXklJa+k5JWUvJKSV1LySkpeSckrKXklJa+k5JWUvJKSV1LySkpeScmrF7Tb20sn+pVXt5aiOQ6+yN2prehe9Cjaiy7bW/JKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS15pySsteaUlr7TklZa80pJXWvJKS7/S0q+09Cst/UpLv9LSr7T0Ky39Sku/0tKvtOSVlrxqJa9ayatW8qqVvGolr1rJq1byqpW8aiWvWsmrVvKqlbxqJa9ayatW8qqVvGolr1rJq1byqpW8aiWvWsmrVvKqlbxqJa9ayatW8qqVvGolr1rJq1byqpW8aiWvWsmrVvKqlbxqJa9ayatW8qqVvGolr1408es4+MKJp25FW9EcB19I8dRedBTN99AXVjx12d6SV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXrWSV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXrWSV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXrWSV63kVSt51UpetZJXreRVK3nVSl61klet5FUredVKXlnJKyt5ZSWvrOSVlbyykldW8spKXlnJKyt5ZSWvrOSVlbyykldW8spKXlnJKyt5ZSWvrOSVlbyykldW8spKXlnJKyt5ZSWvrOSVlbyykldW8spKXlnJKyt5ZSWvrOSVlbyykldW8spKXlnJKyv9ykq/stKvrPQrK/3KSr+y0q+s9Csr/cpKv7KSV1byykpeWckrK3llJa+s5JWVvLKSV1byykpeWckrK3llJa+s5JWVvLKSV1byykpeWckrK3llJa+s5JWVvLKSV1byykpeWckrK3llJa+s5JWVvLKSV1byykpeWckrK3llJa+s5JWVvLKSV1byykpevTDn13HwxTlPPYr2ojkOvljnl37BzlNL0Vp0K5rt7SWvesmrXvKql7zqJa96yate8qqXvOolr3rJq17yqpe86iWvesmrXvKql7zqJa96yate8qqXvOolr3rJq17yqpe86iWvesmrXvKql7zqJa96yate8qqXvOolr3rJq17yqpe86iWvesmrXvKql7zqJa96yate8qqXvOolr3rJq17yqpe86iWvesmrXvKql7zqJa96yate8qqXvOolr3rJq17yqpe86iWvesmrXvKql7zqJa96yate8qqXvOolr3rJq17yqpe86iWvesmrXvKql7zqJa96yate8qqXvOolr3rJq17yqpe86iWvesmrXvKql7zqJa966Ve99Kte+lUv/aqXftVLvxqlX43Sr0bpV6P0q1HyapS8GiWvRsmrUfJqlLwaJa9GyatR8mqUvBolr0bJq1HyapS8GiWvRsmrUfJqlLwaJa9GyatR8mqUvBolr0bJq1HyapS8GiWvRsmrUfJqlLwaJa9GyatR8mqUvBolr0bJq1HyapS8GiWvRsmrUfJqlLwaJa9e/PXrOPgCsKfm99gXgj01x8EXhD11K9qK7kWPosv2lrwaJa9GyatR8mqUvBolr0bJq1HyapS8GiWvRsmrUfJqlLwaJa9GyatR8mqUvBolr0bJq1HyapS8GiWvRsmrUfJqlLwaJa9GyatR8mqUvBolr0bJq1HyapS8GiWvRsmrUfJqlLwaJa9GyatR8mqUvBolr7zklZe88pJXXvLKS155ySsveeUlr7zklZe88pJXXvLKS155ySsveeUlr7zklZe88pJXXvLKS155ySsveeUlr7zklZe88pJXXvLKS155ySsveeUlr7zklZe88pJXXvLKS155ySsveeUlr7zklZe88pJXXvLKS155ySsveeWlX3npV176lZd+5aVfeelXXvqVl37lpV956Vde8spLXnnJKy955SWvvOSVl7zyklde8spLXnnJKy955SWvvOSVl7zyklde8spLXnnJKy955SWvvOSVl7zyklde8spLXnnJKy955SWvvOSVl7zyklde8spLXnnJKy955SWvvOSVl7zyklde8spLXnnJqxcY/joOvsjwqbXoVjTHwRcdPvUo2ouOovkeGiWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8ipKXkXJqyh5FSWvouRVln6VpV9l6VdZ+lWWfpWlX2XpV1n6VZZ+laVfZcmrLHmVJa+y5FWWvMqSV1nyKkteZcmrLHmVJa+y5FWWvMqSV1nyKkteZcmrLHmVJa+y5FWWvMqSV1nyKkteZcmrLHmVJa+y5FWWvMqSV1nyKkteZcmrLHmVJa+y5FWWvMqSV1nyKkteZcmrLHmVJa9uYr29tBXdix5Fcxy8sfVbcxy8wfVbS9FadNnekldZ8ipLXmXJqyx5lSWvsuRVlrzKkldZ8ipLXmXJqyx5lSWvsuRVlrzKkldZ8ipLXmXJqyx5lSWvsuRVlrzKkldZ8ipLXmXJqyx5lSWvsuRVlrzKkldZ8ipLXhW+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLscrfha8bXia8XXiq8VXyu+Vnyt+FrxteLbi28vvr349uLbi28vvr349uLbi28vvqP4juI7iu8ovqP4juI7iu8ovqP4juLrxdeLrxdfL75efL34evH14uvF14tvFN8ovlF8o/hG8Y3iG8U3im8U3yi+WXyz+GbxzeKbxTeLbxbfLL5ZfEteFb5dCt8uhW+XwrdL4dul8O1y8+3tpb3oKDrRso6DcvPtt9aiW9FWdC+a7S18uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7SIlr6TklZS8kpJXUvJKSl5JySspeSUlr6TkVeHbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl1uvv06Dt58+62laC2a4+DNt9+6Fz2K9qKj6LK9Ja8K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HZpJa9ayatW8qqVvGolr1rJq1byqpW8aiWvWsmrwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8u9x8e3vpVrQV3YvmOHjz7beOohOtR9FSdNnekleFb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLtYySsreWUlr6zklZW8spJXveRVL3nVS171kleFb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2ufn29tKjaC86iuY4ePPtt5aitehWtBVdtrfkVeHbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLqPk1Sh5NUpejZJXo+TVKHk1Sl6Nklej5NUoeVX4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+Xm29vL83vsTfffmspmuOgayvaiu5Fj6K96LK9Ja8K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HaJkldR8ipKXkXJqyh5FSWvouRVlLyKkldR8qrw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+PYfXXxLXhW+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl1uvr29tBbdiraiOQ7efPutvegomu+hN99+67K9Ja8K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HbJkldZ8ipLXmXJqyx5lSWvsuRVlrzKkldZ8qrw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt8uhW+XwrdL4dul8O1S+HYpfLsUvl0K3y6Fb5fCt0vh26Xw7VL4dil8uxS+XQrfLoVvl8K3S+HbpfDtUvh2KXy7FL5dCt+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di18uxa+XQvfroVv18K3a+HbtfDtWvh2LXy7Fr5dC9+uN9/eXroXPYr2otdxUI/1pIgTYTuKlqK16FZ02d5WtreV7W1le1vZ3la218r2WtleK9trZXut+FrxteJrxdeKrxXfXnx78e3FtxffXnx78e3FtxffXnx78R3FdxTfUXxH8R3FdxTfUXxH8R3FdxRfL75efL34evH14uvF14uvF18vvl58o/hG8Y3iG8U3im8U3yi+UXyj+EbxzeKbxTeLbxbfLL5ZfLP4ZvHN4lvyqvDtWvh2LXy7Fr5dC9+uhW/Xcv92Lfdv13L/di33b9dy/3Yt92/Xcv92Lfdv13L/di33b9fCt2vh27Xw7Vr4di18uxa+XQvfroVv18K3a+HbtfDtWvh2LXy7Fr5dC9+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di18uxa+XQvfroVv18K3a+HbtfDtWvh2LXy7Fr5dC9+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di18uxa+XQvfroVv18K3a+HbtfDtWvh2LXy73nx7e+koOtFxFM1x8Obbb92KtqJ70aPosr0lrwrfroVv18K3a+HbtfDtWvh2LXy7Fr5dC9+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di18uxa+XQvfroVv18K3a+HbtfDtWvh2LXy7Fr5dC9+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di18uxa+XQvfroVv18K3a+HbtfDtWvh2LXy7Fr5dC9+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di33b9dy/3Yt92/Xcv92Lfdv13L/di33b9dy/3Yt92/Xcv92LXy7Fr5dC9+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di18uxa+XQvfroVv18K3a+HbtfDtWvh2LXy7Fr5dC9+uhW/Xwrdr4du18O1a+HYtfLsWvl0L366Fb9fCt2vh27Xw7Vr4di18uxa+XQvfroVv1/9fU3e3Ykl7ZAf4XnSsg861Iv98K0YMM7JsBGI0yDMGY3Tvrnpzd+VzIiKq9PWKXd07djc8ROLbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg2/Px7f3qUNd6qF+Pwc/vv1Tn9QX9fvv0L7P8wq+Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NvD/fZwvz3cbw/328P99nC/PdxvD/fbw/32cL89+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24Nvz8e396kP6pP6on4/Bz++/VNv1KEu9VDzetlX+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD7493G8P99vD/fZwvz3cbw/328P99nC/PdxvD/fbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDb8/Ht6zPx49s/9UYd6vdz8Hif75zjfZ5Xjvd5Xjne53nleJ/nFXx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx78O3BtwffHnx7uN8e7reH++3hfnu43x7ut4f77eF+e7jfHu63B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B98efHvw7cG3B9+ej2/vUw/1Tn1Qv5+D5/s8r5zv87xyvc/zyvU+zyvX+zyv4NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24Nu/anLZV/j24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj24NuDbw++Pfj2cL893G8P99vD/fZwvz3cbw/328P99nC/PdxvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbg24NvD749+Pbc7/O8cr/P88r9Ps8r9/s8r9zv87xyv8/zyv0+zyv3+zyv3O/zvHK/z/MKvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbg28Pvj349uDbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLby/32cr+93G8v99vL/fZyv73cby/328v99nK/vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLb+/2Ps+r2/s8r27v87z68e2f+udzsNv7PK9u7/O8ur3P8+r2Ps+r3G8vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349nK/vdxvL/fby/32cr+93G8v99vL/fZyv73cby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLby++vfj24tuLb2/e53k17/O8+vHtn/qifj8H8z7Pq3mf59W8z/Mq99vL/fbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL/fby/32cr+93G8v99vL/fZyv73cby/328v99uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349s77PK9+fPun3qhD/X4Ozvs8r877PK9yv73cby/324tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL769+Pbi24tvL7693G8v99vL/fZyv73cby/328v99nK/vdxvL/fbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLbi28vvr349uLb+/Htfeqh3qkP6vdzcH+f51Xut5f77eV+e7nfXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3lfnu5317ut5f77eV+e7nfXu63l/vt5X57ud9efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F9/ej2/vU1/U779Dud/e832eV7nfXu63l/vt5X57ud9efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7eV+e7nfXu63l/vt5X57ud9e7reX++3lfnu53158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158+1dNLvsK3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX3158e/HtxbcX317ut5f77eV+e7nfXu63l/vt5X57ud9e7reX++3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXnx78e3FtxffXu63l/vt5X57ud9e7reX++3lfnu5317ut5f77cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efHvx7cW3F99efPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg24f77cP99uF++3x8+6f++Rwc7rcP99uH++3D/fb5+PZPzestr7e83vJ6y+sdXu/weofXO7ze4fUOuUPukDvkDrk7uTu5O7k7uTu5O7k7uTu5O7k7uQe5B7kHuQe5B7kHuQe5B7kHuQe5J7knuSe5J7knuSe5J7knuSe5J7kXuRe5F7kXuRe5F7kXuRe5F7kXuTe5N7k3uTe5N7k3uTe5N7k3uewrfPtwv3243z7cbx/utw/324f77cP99uF++3C/fbjfPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtw/324X77fHz7pw71+znI/fbhfvtwv30+vv1TX9S8XvYVvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw/324f77cP99uF++3C/fbjfPtxvH+63D/fbh/vtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98+3G8f7rfPx7d/6oP6/Rzkfvtwv3243z4f3/6pQ83rZV/h2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98+3C/fbjfPtxvH+63D/fbh/vtw/324X77cL99uN8++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O3D/fbhfvt8fPtT37+o389B7rcP99uH++3z8e2f+qDm9bKv8O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn243z7cbx/utw/324f77cP99uF++3C/fbjfPtxvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj2wbcPvn3w7YNvH3z74NsH3z749sG3D7598O2Dbx98++DbB98++PbBtw++ffDtg28ffPvg2wffPvj24X77cL99Pr79Uw/1yt2f+qA+qS/q+62fffWpv3OPeepQl3qod+qD+qS+qO+3Xvvqd03uQe5B7kHuQe5B7kHuQe5B7knuSe5J7knuSe5J7knuSe5J7knuRe5F7kXuRe5F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","file_map":{"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function assumes that the points are on the curve\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // avoid calling the black box function for trivial cases\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_inner(point1, point2)\n        }\n    } else {\n        embedded_curve_add_inner(point1, point2)\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// EC addition wrapper for the foreign function\nfn embedded_curve_add_inner(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"51":{"source":"mod utils;\n\nuse dep::protocol_types::{\n    hash::poseidon2_hash,\n    merkle_tree::root::root_from_sibling_path,\n};\nuse utils::{\n    PLAINTEXT_BYTES_LEN, CIPHERTEXT_BYTES_LEN, MAX_LOTS, LOT_TREE_HEIGHT,\n    Lot, PriceWitness,\n    compute_public_data_tree_index,\n    derive_storage_slot_in_map,\n    extract_plaintext_field,\n    hash_lots,\n    verify_and_read_public_data,\n    verify_encryption,\n};\n\n/// Proves a single swap event and computes FIFO capital gains across a multi-token lot state tree.\n/// Each swap updates two leaves: sell-side (token_in) and buy-side (token_out).\n///\n/// Oracle prices must have at most 4 decimal precision (scaled by 10^4).\n/// Token amounts must fit in i64 (< 9.2 * 10^18).\n///\n/// Returns: (leaf_hash, pnl_abs, pnl_is_negative, remaining_lot_state_root, initial_lot_state_root, price_feed_address, block_number)\nfn main(\n    // Swap event\n    plaintext_bytes: [u8; PLAINTEXT_BYTES_LEN],\n    eph_pk_x: Field,\n    ciphertext_bytes: [u8; CIPHERTEXT_BYTES_LEN],\n    ivsk_app: Field,\n    block_number: Field,\n\n    // Lot state tree root (before this swap)\n    initial_lot_state_root: Field,\n\n    // Sell-side token (token_in)\n    sell_lots: [Lot; MAX_LOTS],\n    sell_num_lots: u32,\n    sell_leaf_index: Field,\n    sell_sibling_path: [Field; LOT_TREE_HEIGHT],\n\n    // Buy-side token (token_out)\n    buy_lots: [Lot; MAX_LOTS],\n    buy_num_lots: u32,\n    buy_leaf_index: Field,\n    buy_sibling_path: [Field; LOT_TREE_HEIGHT], // against INTERMEDIATE root (after sell update)\n\n    // Oracle prices for BOTH tokens\n    price_feed_address: Field,\n    price_feed_assets_slot: Field,\n    public_data_tree_root: Field,\n    sell_price_witness: PriceWitness,\n    buy_price_witness: PriceWitness,\n\n    // Chronological ordering\n    previous_block_number: Field,\n) -> pub (Field, Field, Field, Field, Field, Field, Field) {\n    // 1. Verify encryption (proves swap event is authentic)\n    verify_encryption(plaintext_bytes, eph_pk_x, ciphertext_bytes, ivsk_app);\n\n    // 2. Extract swap values from plaintext\n    // Layout: [metadata, randomness, token_in, token_out, amount_in, amount_out, is_exact_input]\n    let token_in = extract_plaintext_field(plaintext_bytes, 2);\n    let token_out = extract_plaintext_field(plaintext_bytes, 3);\n    let amount_in = extract_plaintext_field(plaintext_bytes, 4);\n    let amount_out = extract_plaintext_field(plaintext_bytes, 5);\n    let is_exact_input = extract_plaintext_field(plaintext_bytes, 6);\n\n    // 3. Assert chronological ordering\n    let bn: u64 = block_number as u64;\n    let prev_bn: u64 = previous_block_number as u64;\n    assert(bn >= prev_bn, \"Block number must be >= previous block number\");\n\n    // 4. Compute leaf hash (commits to the raw swap data)\n    let leaf = poseidon2_hash(\n        [block_number, token_in, token_out, amount_in, amount_out, is_exact_input],\n    );\n\n    // 5. SELL SIDE: Verify sell lots in initial root, consume FIFO, compute PnL\n    let old_sell_hash = hash_lots(token_in, sell_lots, sell_num_lots);\n    let computed_initial_root = root_from_sibling_path(old_sell_hash, sell_leaf_index, sell_sibling_path);\n    assert_eq(computed_initial_root, initial_lot_state_root, \"Sell-side merkle proof failed against initial root\");\n\n    // Read sell token oracle price\n    let sell_token_slot = derive_storage_slot_in_map(price_feed_assets_slot, token_in);\n    let sell_tree_index = compute_public_data_tree_index(price_feed_address, sell_token_slot);\n    let sell_price = verify_and_read_public_data(\n        public_data_tree_root, sell_tree_index, sell_price_witness,\n    );\n    assert(sell_price != 0, \"Sell token price must not be zero\");\n\n    // Consume sell-side lots FIFO with i64 PnL\n    let mut sell_lots_mut = sell_lots;\n    let mut sell_num = sell_num_lots;\n    let mut pnl: i64 = 0;\n\n    let sell_price_i64: i64 = sell_price as i64;\n    let mut remaining: i64 = amount_in as i64;\n\n    for j in 0..MAX_LOTS {\n        let lot_amount: i64 = sell_lots_mut[j].amount as i64;\n        let lot_cost: i64 = sell_lots_mut[j].cost_per_unit as i64;\n\n        if (remaining != 0) & (lot_amount != 0) {\n            let consumed: i64 = if remaining < lot_amount { remaining } else { lot_amount };\n\n            let proceeds = consumed * sell_price_i64;\n            let cost = consumed * lot_cost;\n            pnl += proceeds - cost;\n\n            sell_lots_mut[j].amount = (lot_amount - consumed) as u64 as Field;\n            remaining -= consumed;\n        }\n    }\n    assert(remaining == 0, \"Not enough lots to cover sell amount\");\n\n    // Compact sell lots\n    let mut compacted_sell: [Lot; MAX_LOTS] = [Lot { amount: 0, cost_per_unit: 0 }; MAX_LOTS];\n    let mut write_idx: u32 = 0;\n    for j in 0..MAX_LOTS {\n        if sell_lots_mut[j].amount != 0 {\n            compacted_sell[write_idx] = sell_lots_mut[j];\n            write_idx += 1;\n        }\n    }\n    sell_num = write_idx;\n\n    // 6. Compute intermediate root (after sell update)\n    let new_sell_hash = hash_lots(token_in, compacted_sell, sell_num);\n    let intermediate_root = root_from_sibling_path(new_sell_hash, sell_leaf_index, sell_sibling_path);\n\n    // 7. BUY SIDE: Verify buy lots in intermediate root, add new lot\n    let old_buy_hash = hash_lots(token_out, buy_lots, buy_num_lots);\n    let computed_intermediate_root = root_from_sibling_path(old_buy_hash, buy_leaf_index, buy_sibling_path);\n    assert_eq(computed_intermediate_root, intermediate_root, \"Buy-side merkle proof failed against intermediate root\");\n\n    // Read buy token oracle price\n    let buy_token_slot = derive_storage_slot_in_map(price_feed_assets_slot, token_out);\n    let buy_tree_index = compute_public_data_tree_index(price_feed_address, buy_token_slot);\n    let buy_price = verify_and_read_public_data(\n        public_data_tree_root, buy_tree_index, buy_price_witness,\n    );\n    assert(buy_price != 0, \"Buy token price must not be zero\");\n\n    // Add new lot on buy side\n    let mut buy_lots_mut = buy_lots;\n    let mut buy_num = buy_num_lots;\n    assert((buy_num as u64) < (MAX_LOTS as u64), \"Buy lot array full\");\n    buy_lots_mut[buy_num] = Lot { amount: amount_out, cost_per_unit: buy_price };\n    buy_num += 1;\n\n    // 8. Compute final root (after buy update)\n    let new_buy_hash = hash_lots(token_out, buy_lots_mut, buy_num);\n    let final_root = root_from_sibling_path(new_buy_hash, buy_leaf_index, buy_sibling_path);\n\n    // 9. Encode signed PnL as (magnitude, is_negative) for Field output\n    let pnl_is_negative: Field = if pnl < 0 { 1 } else { 0 };\n    let pnl_abs: Field = if pnl < 0 { (-pnl) as u64 as Field } else { pnl as u64 as Field };\n\n    (leaf, pnl_abs, pnl_is_negative, final_root, initial_lot_state_root, price_feed_address, block_number)\n}\n","path":"/Users/jp4g/Workground/aztec/fde/pnl-proof/circuits/individual_swap/src/main.nr"},"52":{"source":"use dep::aztec::{\n    messages::encryption::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe,\n    keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n    utils::point::{point_from_x_coord_and_sign, get_sign_of_point},\n};\nuse dep::std::{aes128::aes128_encrypt, embedded_curve_ops::EmbeddedCurveScalar};\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::{poseidon2_hash, poseidon2_hash_with_separator},\n    merkle_tree::root::root_from_sibling_path,\n    utils::field::full_field_less_than,\n};\n\n// ============================================================\n// Public Data Tree\n// ============================================================\n\npub global PUBLIC_DATA_TREE_HEIGHT: u32 = 40;\n\npub struct PublicDataLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl PublicDataLeafPreimage {\n    pub fn hash(self) -> Field {\n        let is_empty = (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0);\n        if is_empty {\n            0\n        } else {\n            poseidon2_hash([self.slot, self.value, self.next_index, self.next_slot])\n        }\n    }\n}\n\npub struct PriceWitness {\n    pub leaf_preimage: PublicDataLeafPreimage,\n    pub witness_index: Field,\n    pub witness_path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\npub fn compute_public_data_tree_index(contract_address: Field, storage_slot: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address, storage_slot],\n        GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    )\n}\n\npub fn derive_storage_slot_in_map(storage_slot: Field, key: Field) -> Field {\n    poseidon2_hash([storage_slot, key])\n}\n\npub fn verify_and_read_public_data(\n    public_data_tree_root: Field,\n    tree_index: Field,\n    witness: PriceWitness,\n) -> Field {\n    let leaf_hash = witness.leaf_preimage.hash();\n    let computed_root = root_from_sibling_path(leaf_hash, witness.witness_index, witness.witness_path);\n    assert_eq(computed_root, public_data_tree_root, \"Merkle membership proof failed\");\n\n    let is_less_than_slot = full_field_less_than(witness.leaf_preimage.slot, tree_index);\n    let is_next_greater_than = full_field_less_than(tree_index, witness.leaf_preimage.next_slot);\n    let is_max = (witness.leaf_preimage.next_index == 0) & (witness.leaf_preimage.next_slot == 0);\n    let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n    if is_in_range {\n        0\n    } else {\n        assert_eq(witness.leaf_preimage.slot, tree_index, \"Public data tree index doesn't match witness\");\n        witness.leaf_preimage.value\n    }\n}\n\n// ============================================================\n// Byte Helpers\n// ============================================================\n\npub global SWAP_PLAINTEXT_FIELDS: u32 = 7;\npub global PLAINTEXT_BYTES_LEN: u32 = 224; // 7 fields * 32 bytes\npub global CIPHERTEXT_BYTES_LEN: u32 = 496; // 16 ciphertext fields * 31 bytes each\nglobal HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    for i in 0..32 {\n        result = result * 256 + bytes[i] as Field;\n    }\n    result\n}\n\npub fn extract_plaintext_field(plaintext_bytes: [u8; PLAINTEXT_BYTES_LEN], index: u32) -> Field {\n    let mut field_bytes = [0 as u8; 32];\n    let offset = index * 32;\n    for j in 0..32 {\n        field_bytes[j] = plaintext_bytes[offset + j];\n    }\n    bytes_to_field(field_bytes)\n}\n\n// ============================================================\n// Encryption Verification\n// ============================================================\n\npub fn verify_encryption(\n    plaintext_bytes: [u8; PLAINTEXT_BYTES_LEN],\n    eph_pk_x: Field,\n    ciphertext_bytes: [u8; CIPHERTEXT_BYTES_LEN],\n    ivsk_app: Field,\n) {\n    let eph_pk_sign_byte = ciphertext_bytes[0];\n    let eph_pk_sign = eph_pk_sign_byte != 0;\n\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign)\n        .expect(f\"Invalid ephemeral public key x-coordinate\");\n    let recipient_sk_scalar = EmbeddedCurveScalar::from_field(ivsk_app);\n    let shared_secret = derive_ecdh_shared_secret(recipient_sk_scalar, eph_pk);\n\n    let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(shared_secret);\n    let (body_sym_key, body_iv) = pairs[0];\n\n    let computed_body = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n    let body_start = 1 + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    for i in 0..computed_body.len() {\n        if body_start + i < ciphertext_bytes.len() {\n            assert(\n                computed_body[i] == ciphertext_bytes[body_start + i],\n                \"Body ciphertext mismatch\",\n            );\n        }\n    }\n\n    assert(eph_pk_sign_byte == get_sign_of_point(eph_pk) as u8, \"Ephemeral PK sign mismatch\");\n}\n\n// ============================================================\n// FIFO Lot Tracking\n// ============================================================\n\npub global MAX_LOTS: u32 = 32;\npub global LOTS_HASH_PREIMAGE_LEN: u32 = 66; // MAX_LOTS * 2 + 2 (token_address + num_lots)\npub global LOT_TREE_HEIGHT: u32 = 3; // 8 token slots\n\npub struct Lot {\n    pub amount: Field,\n    pub cost_per_unit: Field,\n}\n\npub fn hash_lots(token_address: Field, lots: [Lot; MAX_LOTS], num_lots: u32) -> Field {\n    if num_lots == 0 {\n        0\n    } else {\n        let mut preimage: [Field; LOTS_HASH_PREIMAGE_LEN] = [0; LOTS_HASH_PREIMAGE_LEN];\n        preimage[0] = token_address;\n        preimage[1] = num_lots as Field;\n        for i in 0..MAX_LOTS {\n            preimage[2 + i * 2] = lots[i].amount;\n            preimage[2 + i * 2 + 1] = lots[i].cost_per_unit;\n        }\n        poseidon2_hash(preimage)\n    }\n}\n","path":"/Users/jp4g/Workground/aztec/fde/pnl-proof/circuits/individual_swap/src/utils.nr"},"95":{"source":"use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ECDH shared secret: secret * public_key = shared_secret.\n///\n/// The input secret is known only to one party. The output shared secret can be derived given knowledge of\n/// `public_key`'s key-pair and the public ephemeral secret, using this same function (with reversed inputs).\n///\n/// E.g.:\n/// Epk = esk * G // ephemeral key-pair\n/// Pk = sk * G // recipient key-pair\n/// Shared secret S = esk * Pk = sk * Epk\n///\n/// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    multi_scalar_mul([public_key], [secret])\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().unwrap().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().unwrap().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret =\n        derive_ecdh_shared_secret(secret_a, address_b.to_address_point().unwrap().inner);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr"},"133":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"238":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"249":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/jp4g/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"338":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"347":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"390":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"}},"expression_width":{"Bounded":{"width":4}}}