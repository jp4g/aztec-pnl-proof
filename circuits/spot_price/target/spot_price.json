{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"13919837618341158810","abi":{"parameters":[{"name":"amm_address","type":{"kind":"field"},"visibility":"private"},{"name":"token0_address","type":{"kind":"field"},"visibility":"private"},{"name":"token1_address","type":{"kind":"field"},"visibility":"private"},{"name":"block_number","type":{"kind":"field"},"visibility":"private"},{"name":"public_data_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"token_public_balances_slot","type":{"kind":"field"},"visibility":"private"},{"name":"token0_leaf_preimage","type":{"kind":"struct","path":"PublicDataLeafPreimage","fields":[{"name":"slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"next_slot","type":{"kind":"field"}},{"name":"next_index","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token0_witness_index","type":{"kind":"field"},"visibility":"private"},{"name":"token0_witness_path","type":{"kind":"array","length":40,"type":{"kind":"field"}},"visibility":"private"},{"name":"token1_leaf_preimage","type":{"kind":"struct","path":"PublicDataLeafPreimage","fields":[{"name":"slot","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"next_slot","type":{"kind":"field"}},{"name":"next_index","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token1_witness_index","type":{"kind":"field"},"visibility":"private"},{"name":"token1_witness_path","type":{"kind":"array","length":40,"type":{"kind":"field"}},"visibility":"private"},{"name":"price_precision","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"2014890719615096298":{"error_kind":"string","string":"Field failed to decompose into specified 40 limbs"},"4648451262681811962":{"error_kind":"string","string":"Public data tree index doesn't match witness"},"10791179381245553740":{"error_kind":"string","string":"AMM has no liquidity for token0"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"18055728914098955818":{"error_kind":"string","string":"Merkle membership proof failed"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::{poseidon2_hash, poseidon2_hash_with_separator},\n    merkle_tree::root::root_from_sibling_path,\n    utils::field::full_field_less_than,\n};\n\n/// Public data tree height in Aztec\nglobal PUBLIC_DATA_TREE_HEIGHT: u32 = 40;\n\n/// Preimage of a public data tree leaf (indexed tree)\nstruct PublicDataLeafPreimage {\n    slot: Field,\n    value: Field,\n    next_slot: Field,\n    next_index: Field,\n}\n\nimpl PublicDataLeafPreimage {\n    fn hash(self) -> Field {\n        let is_empty = (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0);\n        if is_empty {\n            0\n        } else {\n            poseidon2_hash([self.slot, self.value, self.next_index, self.next_slot])\n        }\n    }\n}\n\n/// Compute the public data tree leaf index for a storage slot in a contract.\n/// This \"silos\" the slot with the contract address using poseidon2 with a generator separator.\nfn compute_public_data_tree_index(contract_address: Field, storage_slot: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address, storage_slot],\n        GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    )\n}\n\n/// Derive the storage slot for a map entry: hash(map_slot, key)\nfn derive_storage_slot_in_map(storage_slot: Field, key: Field) -> Field {\n    poseidon2_hash([storage_slot, key])\n}\n\n/// Verify a public data tree Merkle membership proof and extract the stored value.\n/// Returns the value at the given tree_index, or 0 if the slot was never written.\nfn verify_and_read_public_data(\n    public_data_tree_root: Field,\n    tree_index: Field,\n    leaf_preimage: PublicDataLeafPreimage,\n    witness_index: Field,\n    witness_path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n) -> Field {\n    // 1. Verify the leaf exists in the tree\n    let leaf_hash = leaf_preimage.hash();\n    let computed_root = root_from_sibling_path(leaf_hash, witness_index, witness_path);\n    assert_eq(computed_root, public_data_tree_root, \"Merkle membership proof failed\");\n\n    // 2. Determine the value using indexed tree logic\n    let is_less_than_slot = full_field_less_than(leaf_preimage.slot, tree_index);\n    let is_next_greater_than = full_field_less_than(tree_index, leaf_preimage.next_slot);\n    let is_max = (leaf_preimage.next_index == 0) & (leaf_preimage.next_slot == 0);\n    let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n    if is_in_range {\n        // Slot was never written - default value is 0\n        0\n    } else {\n        // Slot exists - leaf preimage directly contains the value\n        assert_eq(leaf_preimage.slot, tree_index, \"Public data tree index doesn't match witness\");\n        leaf_preimage.value\n    }\n}\n\n/// Spot price proof circuit.\n///\n/// Proves the spot price of an AMM (Uniswap V2 constant-product) at a specific historical block\n/// by verifying the public balances of the AMM in each token contract's public data tree.\n///\n/// Returns: (price, block_number, public_data_tree_root, amm_address, token0_address, token1_address)\nfn main(\n    // Addresses\n    amm_address: Field,\n    token0_address: Field,\n    token1_address: Field,\n    // Block context\n    block_number: Field,\n    public_data_tree_root: Field,\n    // Storage slot of `public_balances` map in the Token contract (varies by contract version)\n    token_public_balances_slot: Field,\n    // Token0 witness\n    token0_leaf_preimage: PublicDataLeafPreimage,\n    token0_witness_index: Field,\n    token0_witness_path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n    // Token1 witness\n    token1_leaf_preimage: PublicDataLeafPreimage,\n    token1_witness_index: Field,\n    token1_witness_path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n    // Price computation parameter\n    price_precision: Field,\n) -> pub (Field, Field, Field, Field, Field, Field) {\n    // 1. Derive storage slots\n    // Token contract stores public_balances as a Map<AztecAddress, u128>.\n    // The derived slot for a specific key is: poseidon2_hash([map_slot, key])\n    let token0_map_slot = derive_storage_slot_in_map(token_public_balances_slot, amm_address);\n    let token1_map_slot = derive_storage_slot_in_map(token_public_balances_slot, amm_address);\n\n    // Silo with contract address to get the public data tree index\n    let token0_tree_index = compute_public_data_tree_index(token0_address, token0_map_slot);\n    let token1_tree_index = compute_public_data_tree_index(token1_address, token1_map_slot);\n\n    // 2. Verify Merkle membership and extract balances\n    let balance0 = verify_and_read_public_data(\n        public_data_tree_root,\n        token0_tree_index,\n        token0_leaf_preimage,\n        token0_witness_index,\n        token0_witness_path,\n    );\n\n    let balance1 = verify_and_read_public_data(\n        public_data_tree_root,\n        token1_tree_index,\n        token1_leaf_preimage,\n        token1_witness_index,\n        token1_witness_path,\n    );\n\n    // 3. Compute spot price: price = balance1 * precision / balance0\n    // Caller must ensure balance0 != 0 (AMM has liquidity)\n    assert(balance0 != 0, \"AMM has no liquidity for token0\");\n    let price = balance1 * price_precision / balance0;\n\n    // 4. Return public outputs\n    (price, block_number, public_data_tree_root, amm_address, token0_address, token1_address)\n}\n","path":"/Users/jp4g/Workground/aztec/fde/pnl-proof/circuits/spot_price/src/main.nr"},"139":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"148":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"191":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"204":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/jp4g/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}