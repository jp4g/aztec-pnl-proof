{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"6373992445579042999","abi":{"parameters":[{"name":"note_value","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"randomness","type":{"kind":"field"},"visibility":"private"},{"name":"note_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"contract_address","type":{"kind":"field"},"visibility":"private"},{"name":"before_block_number","type":{"kind":"field"},"visibility":"private"},{"name":"before_tree_size","type":{"kind":"field"},"visibility":"private"},{"name":"inclusion_block_number","type":{"kind":"field"},"visibility":"private"},{"name":"note_hash_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"note_leaf_index","type":{"kind":"field"},"visibility":"private"},{"name":"note_sibling_path","type":{"kind":"array","length":42,"type":{"kind":"field"}},"visibility":"private"},{"name":"nsk_app","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier_tree_root","type":{"kind":"field"},"visibility":"private"},{"name":"low_nullifier_preimage","type":{"kind":"struct","path":"NullifierLeafPreimage","fields":[{"name":"nullifier","type":{"kind":"field"}},{"name":"next_nullifier","type":{"kind":"field"}},{"name":"next_index","type":{"kind":"field"}}]},"visibility":"private"},{"name":"low_nullifier_index","type":{"kind":"field"},"visibility":"private"},{"name":"low_nullifier_path","type":{"kind":"array","length":42,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"123769615562074991":{"error_kind":"string","string":"Note hash tree inclusion proof failed"},"6365798118994747278":{"error_kind":"string","string":"Nullifier non-inclusion check failed: nullifier not in gap"},"11487962331567083946":{"error_kind":"string","string":"Low nullifier is not less than target nullifier"},"11661905180576082158":{"error_kind":"string","string":"Field failed to decompose into specified 42 limbs"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"13124638592791656691":{"error_kind":"string","string":"Nullifier tree membership proof failed"},"14740412126467843646":{"error_kind":"string","string":"Note existed before the specified block"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15782400182525160564":{"error_kind":"string","string":"before_block_number must be less than inclusion_block_number"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator},\n    merkle_tree::root::root_from_sibling_path,\n    utils::field::full_field_less_than,\n};\n\n// Tree heights\nglobal NOTE_HASH_TREE_HEIGHT: u32 = 42;\nglobal NULLIFIER_TREE_HEIGHT: u32 = 42;\n\n// Generator indices (from protocol constants)\nglobal GENERATOR_INDEX__NOTE_HASH: u32 = 1;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH: u32 = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH: u32 = 4;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER: u32 = 7;\nglobal GENERATOR_INDEX__NOTE_NULLIFIER: u32 = 53;\n\n/// Preimage of a nullifier tree leaf (indexed tree)\nstruct NullifierLeafPreimage {\n    nullifier: Field,\n    next_nullifier: Field,\n    next_index: Field,\n}\n\nimpl NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        let is_empty = (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0);\n        if is_empty {\n            0\n        } else {\n            poseidon2_hash([self.nullifier, self.next_nullifier, self.next_index])\n        }\n    }\n}\n\n/// Prove that a private token note (UintNote) was created after a specific block,\n/// still exists at a later block, and has not been nullified.\n///\n/// Returns: (note_value, before_block_number, inclusion_block_number,\n///           contract_address, note_hash_tree_root, nullifier_tree_root)\nfn main(\n    // Note data\n    note_value: Field,\n    owner: Field,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    contract_address: Field,\n    // Block references\n    before_block_number: Field,\n    before_tree_size: Field,\n    inclusion_block_number: Field,\n    // Note hash tree state at inclusion block\n    note_hash_tree_root: Field,\n    // Note inclusion witness\n    note_leaf_index: Field,\n    note_sibling_path: [Field; NOTE_HASH_TREE_HEIGHT],\n    // Nullifier non-inclusion data at inclusion block\n    nsk_app: Field,\n    nullifier_tree_root: Field,\n    low_nullifier_preimage: NullifierLeafPreimage,\n    low_nullifier_index: Field,\n    low_nullifier_path: [Field; NULLIFIER_TREE_HEIGHT],\n) -> pub (Field, Field, Field, Field, Field, Field) {\n    // 1. Compute unique_note_hash (the 4-step hash chain for UintNote)\n    // Step 1: partial_commitment = poseidon2([owner, storage_slot, randomness], separator=1)\n    let commitment = poseidon2_hash_with_separator(\n        [owner, storage_slot, randomness],\n        GENERATOR_INDEX__NOTE_HASH,\n    );\n\n    // Step 2: note_hash = poseidon2([commitment, value], separator=1)\n    let note_hash = poseidon2_hash_with_separator(\n        [commitment, note_value],\n        GENERATOR_INDEX__NOTE_HASH,\n    );\n\n    // Step 3: siloed_note_hash = poseidon2([contract_address, note_hash], separator=4)\n    let siloed_note_hash = poseidon2_hash_with_separator(\n        [contract_address, note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    );\n\n    // Step 4: unique_note_hash = poseidon2([note_nonce, siloed_note_hash], separator=3)\n    let unique_note_hash = poseidon2_hash_with_separator(\n        [note_nonce, siloed_note_hash],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    );\n\n    // 2. INCLUSION: verify Merkle membership of unique_note_hash in note hash tree\n    let computed_root = root_from_sibling_path(\n        unique_note_hash,\n        note_leaf_index,\n        note_sibling_path,\n    );\n    assert_eq(computed_root, note_hash_tree_root, \"Note hash tree inclusion proof failed\");\n\n    // 3. NON-INCLUSION AT BEFORE BLOCK: note didn't exist at the earlier block\n    // The note hash tree is append-only, so if note_leaf_index >= before_tree_size,\n    // the note was not yet in the tree at before_block_number.\n    let note_created_after = full_field_less_than(before_tree_size, note_leaf_index)\n        | (before_tree_size == note_leaf_index);\n    assert(note_created_after, \"Note existed before the specified block\");\n\n    // 4. ORDERING: before_block < inclusion_block\n    assert(\n        full_field_less_than(before_block_number, inclusion_block_number),\n        \"before_block_number must be less than inclusion_block_number\",\n    );\n\n    // 5. NULLIFIER NON-INCLUSION: prove the note has not been spent\n    // Step 5a: Compute the siloed nullifier\n    let inner_nullifier = poseidon2_hash_with_separator(\n        [unique_note_hash, nsk_app],\n        GENERATOR_INDEX__NOTE_NULLIFIER,\n    );\n    let siloed_nullifier = poseidon2_hash_with_separator(\n        [contract_address, inner_nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    );\n\n    // Step 5b: Verify the low nullifier leaf exists in the nullifier tree\n    let low_leaf_hash = low_nullifier_preimage.hash();\n    let computed_nullifier_root = root_from_sibling_path(\n        low_leaf_hash,\n        low_nullifier_index,\n        low_nullifier_path,\n    );\n    assert_eq(\n        computed_nullifier_root,\n        nullifier_tree_root,\n        \"Nullifier tree membership proof failed\",\n    );\n\n    // Step 5c: Assert the siloed nullifier falls in the gap (non-inclusion in indexed tree)\n    // The low nullifier's value must be less than our nullifier\n    assert(\n        full_field_less_than(low_nullifier_preimage.nullifier, siloed_nullifier),\n        \"Low nullifier is not less than target nullifier\",\n    );\n\n    // And either: the next nullifier is greater than ours, or this is the max leaf\n    let is_next_greater = full_field_less_than(siloed_nullifier, low_nullifier_preimage.next_nullifier);\n    let is_max = (low_nullifier_preimage.next_index == 0) & (low_nullifier_preimage.next_nullifier == 0);\n    assert(\n        is_next_greater | is_max,\n        \"Nullifier non-inclusion check failed: nullifier not in gap\",\n    );\n\n    // 6. Return public outputs\n    (\n        note_value,\n        before_block_number,\n        inclusion_block_number,\n        contract_address,\n        note_hash_tree_root,\n        nullifier_tree_root,\n    )\n}\n","path":"/Users/jp4g/Workground/aztec/fde/pnl-proof/circuits/note_creation/src/main.nr"},"139":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"148":{"source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr"},"191":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/Users/jp4g/Workground/aztec/fde/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"204":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/jp4g/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}